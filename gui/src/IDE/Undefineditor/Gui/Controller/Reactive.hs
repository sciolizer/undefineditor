{-# LANGUAGE
 GeneralizedNewtypeDeriving,
 NoMonomorphismRestriction,
 RankNTypes
 #-}
module IDE.Undefineditor.Gui.Controller.Reactive (
  RVar(),
  RVars(),
  RRead(),

  newRVars,

  newRVar,
  newRVarIO,
  getRVars,
  readRVar,
  writeRVar,

  liftRRead,

  cleanly,

  react
) where

import Prelude hiding (catch)

import Control.Applicative
import Control.Concurrent.STM -- (STM(), TVar(), atomically, newTVar, newTVarIO, readTVar, writeTVar)
import Control.Exception -- (SomeException(), catch)
import Control.Monad -- (join)
import Control.Monad.Trans.Class (lift)
import Control.Monad.Trans.Writer (WriterT(), runWriterT, tell)
import qualified Data.Map as M -- (Map(), elems, empty, insert)
import Data.Monoid
import Data.Unique (Unique(), newUnique)
import System.Exit (ExitCode(ExitFailure), exitWith)

import IDE.Undefineditor.Util.ReentrantLock
import IDE.Undefineditor.Util.Safe

-- | Each RVar belongs to an RVars.
data RVar a = RVar
  RVars
  (TVar a) {- reactive variable -}
  (TVar (M.Map Unique Effect)) -- map of effects that must be triggered if this RVar is modified

-- | A Monad for tracking reads on 'RVar's
newtype RRead a = RRead (WriterT [UntypedRVar] STM a)
  deriving (Applicative, Functor, Monad)

-- | Accumulates the queue of effects that need to occur, and
-- also holds a re-entrant lock that ensures the view is updated
-- atomically. Usually you will have only one of these for the entire
-- application.
data RVars = RVars (TVar (M.Map Unique Effect)) ReentrantLock

-- | Creates an instance of 'RVars'; usually only called at the beginning of your program.
newRVars :: IO RVars
newRVars = do
  tvar <- newTVarIO M.empty
  lock <- newReentrantLock
  return (RVars tvar lock)

-- | Gets the 'RVars' associated with this 'RVar'.
getRVars :: RVar a -> RVars
getRVars (RVar rvs _ _) = rvs

-- | Executes the reads in a 'RRead' transaction. Most of the
-- time, this will be followed by a write to an 'RVar'. If you intend
-- to update the view based on the result of this 'RRead', you
-- should probably be using the 'react' function instead.
liftRRead :: RRead a -> STM a
liftRRead (RRead m) = fst `fmap` runWriterT m

-- Run through all of the reads, accumulating a list of RVars as you go.
-- Add an action to each of those RVars...
--   the first thing this action does is remove itself from all of the
--     RVars that it was added to (so this action only executes once)
--     then it re-runs all of the reads, and creates a new action

-- | Creates a new 'RVar' with the given initial value and belonging to the given 'RVars'.
newRVar :: RVars -> a -> STM (RVar a)
newRVar = mkRVar newTVar

newRVarIO :: RVars -> a -> IO (RVar a)
newRVarIO = mkRVar newTVarIO

mkRVar :: (Monad m) => (forall a. a -> m (TVar a)) -> RVars -> a -> m (RVar a)
mkRVar mkr rvars x = do
  v <- mkr x
  dependencies <- mkr M.empty
  return (RVar rvars v dependencies)

-- | Reads the value of the 'RVar'.
readRVar :: RVar a -> RRead a
readRVar (RVar _ v deps) = RRead $ do
  tell [\u e -> modifyTVar deps (M.insert u e)] 
  lift $ readTVar v

modifyTVar tvar f = writeTVar tvar . f =<< readTVar tvar

-- thanks to the Uniques, we can tell exactly which effects need to be triggered... if an effect depends on two RVars, and both of them are written in the same transaction, you don't want to trigger the effect twice!

-- | Modifies the value of an 'RVar'. The change will probalby trigger
-- a view update, but not until the 'cleanly' block has exited.
writeRVar :: RVar a -> a -> STM ()
writeRVar (RVar (RVars effects lock) v deps) x = do
  ls <- lockState lock
  when (ls /= LockedOnCurrentThread) $ do
    throwSTM (userError "attempted to writeRVar outside the context of a cleanly")
    -- exitWith (ExitFailure 1)
  -- todo: periodically clean out the deps which aren't doing anything (this will require some kind of data change, as the only signal that the action is inert is hidden in a closure generated by the mkChangingAction function)
  -- accumulate side effects in the RVars
  d <- readTVar deps
  effs <- readTVar effects
  writeTVar effects (d `mappend` effs)
  -- and actually write the new value
  writeTVar v x

-- | This executes all "update view" actions that need to be executed
-- as a result of 'RVars' being written to
-- by the given action. The lock inside 'RVars' is held for both the
-- execution of the given action and the execution of all "update view"
-- side effects that result. The lock is re-entrant, so it is safe to
-- call this function inside of gtk signal handlers, which are often
-- triggered when the view is modified. "View update" actions are invoked
-- in LIFO order - that is, the side effects of an inner invocation of
-- cleanly will be executed before the side effects of an outer
-- invocation of cleanly. The outermost invocation of cleanly will not
-- return until 'RVar' modifications cease to propogate. It IS possible for
-- cleanly to get caught in an infinite loop - e.g. model updates
-- cause view updates which cause model updates which cause... and so on.
-- To prevent this, all "change handlers" passed to the 'react' function
-- should test for equality between the old value and the new value of
-- the 'RRead' action, and return immediately if they are equal.
cleanly :: RVars -> IO () -> IO ()
cleanly (RVars effs lock) action = ret where
  ret = do
    putStrLn "attempting to acquire lock for 'cleanly'"
    withLock lock (\b -> action `finally` run b)
    putStrLn "released lock for 'cleanly'"
  run b = do
    putStrLn "propogating effects"
    join $ atomically $ do
      effects <- readTVar effs
      act <- mapM_ safe `fmap` sequence (M.elems effects)
      writeTVar effs M.empty
      return act
    when b $ do
      effects <- readTVarIO effs
      unless (M.null effects) (run b) -- more TVars were written in the propogation of effects, so rerun

-- Nothing means "unregister me"
type Reactee a = RRead (Maybe a)

-- func takes old value first and new value second
-- handler should never raise an exception
-- handler will NOT be executed before this function returns...
-- after all, what "old value" should be passed to the handler?
-- Returned value is the value that will be used as the first "old value".

-- | launches into existence a mapping from model to view. The first
-- argument is a 'RRead' action which reads various 'RVar's. The second
-- argument is the handler which updates the view according to the result
-- of the 'RRead' action. If the 'RRead' action ever returns 'Nothing', the
-- handler is unregistered and made available for garbage collection; it
-- will not fire again. The handler takes two arguments: the old value
-- and the new value. The handler should always compare the two arguments
-- for equality and do nothing when they are equal; this will reduce the
-- chances of infinite loops in the cleanly function. The value returned
-- by the 'react' function is the result of executing the 'RRead' action for
-- the first time; it's value will be given as the first "old" value to
-- the handler when any of the involved 'RVar's are modified and the
-- handler is triggered. Usually the result of the 'react' function can be
-- discarded, since 'react' is usually called right after creation of the
-- involved 'RVar's, whose state is known.
react :: Reactee a -> (a -> a -> IO ()) -> IO (Maybe a) -- todo: return IO a... simplest way to accomplish this is probably to copy and paste the code from the go function... i.e. write a parallel version which returns the oldValue
react (RRead reactee) action = do
  unique <- newUnique
  atomically $ do
    let valMaker = runWriterT reactee
    (a, vars) <- valMaker
    case a of
      Nothing -> return Nothing
      Just z -> do
        e <- mkChangingAction z valMaker action (\e rv -> rv unique e)
        mapM_ (\inst -> inst unique e) vars
        return (Just z)

mkChangingAction :: a -> STM (Maybe a, [UntypedRVar]) -> (a -> a -> IO ()) -> (Effect -> UntypedRVar -> STM ()) -> STM Effect
mkChangingAction oldValue newValueMaker action_ inst = do
  oldValueTVar <- newTVar oldValue
  tvarAct <- newTVar (Just action_)
  let ret = do
        action <- readTVar tvarAct
        case action of
          Nothing -> return (return ()) -- this action has been disabled
          Just act -> do
            ov <- readTVar oldValueTVar
            (nv, vars) <- newValueMaker
            case nv of
              Nothing -> do
                -- disable this action
                writeTVar tvarAct Nothing -- allows action (which probably holds references to widget) to be garbage collected
                return (return ())
              Just z -> do
                writeTVar oldValueTVar z
                mapM_ ((inst :: (Effect -> UntypedRVar -> STM ())) (ret :: Effect)) (vars :: [UntypedRVar])
                return (act ov z)
  return ret

type Effect = STM (IO ()) -- it returns a DIFFERENT IO action each time... each time you invoke this, you discard a new "old value"
type UntypedRVar = Unique -> Effect -> STM () -- just the function which installs effects

-- todo: in fact, go over my e-mail to John Chee and make the changes that I did when I e-mailed him
